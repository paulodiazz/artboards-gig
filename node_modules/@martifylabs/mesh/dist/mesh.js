import { mnemonicToEntropy as le, generateMnemonic as He } from "bip39";
import * as a from "@emurgo/cardano-serialization-lib-nodejs";
import it from "axios";
import { COSEKey as Ne, Label as Z, KeyType as Pe, AlgorithmId as ge, Int as xt, BigNum as Gt, CBORValue as vt, HeaderMap as Rt, Headers as Me, ProtectedHeaderMap as Te, COSESign1Builder as Ve } from "@emurgo/cardano-message-signing-nodejs";
import { customAlphabet as Oe } from "nanoid";
const Ye = {
  mem: 7e6,
  steps: 3e9
}, P = {
  epoch: 0,
  coinsPerUTxOSize: "4310",
  priceMem: 0.0577,
  priceStep: 721e-7,
  minFeeA: 44,
  minFeeB: 155381,
  keyDeposit: "2000000",
  maxTxSize: 16384,
  maxValSize: "5000",
  poolDeposit: "500000000",
  maxCollateralInputs: 3,
  decentralisation: 0,
  maxBlockSize: 98304,
  collateralPercent: 150,
  maxBlockHeaderSize: 1100,
  minPoolCost: "340000000",
  maxTxExMem: "16000000",
  maxTxExSteps: "10000000000",
  maxBlockExMem: "80000000",
  maxBlockExSteps: "40000000000"
}, St = 2147483648, bt = {
  V1: a.Language.new_plutus_v1(),
  V2: a.Language.new_plutus_v2()
}, L = 56, Ge = {
  CERT: a.RedeemerTag.new_cert(),
  MINT: a.RedeemerTag.new_mint(),
  REWARD: a.RedeemerTag.new_reward(),
  SPEND: a.RedeemerTag.new_spend()
}, pt = {
  testnet: ["74", "1598400", "1595967616", "432000"],
  preview: ["0", "0", "1660003200", "86400"],
  preprod: ["0", "0", "1654041600", "432000"],
  mainnet: ["208", "4492800", "1596059091", "432000"]
}, Lt = {
  ALONZO: a.TxBuilderConstants.plutus_alonzo_cost_models(),
  BABBAGE: a.TxBuilderConstants.plutus_vasil_cost_models()
}, Re = {
  ALONZO: {
    V1: "a141005901d59f1a000302590001011a00060bc719026d00011a000249f01903e800011a000249f018201a0025cea81971f70419744d186419744d186419744d186419744d186419744d186419744d18641864186419744d18641a000249f018201a000249f018201a000249f018201a000249f01903e800011a000249f018201a000249f01903e800081a000242201a00067e2318760001011a000249f01903e800081a000249f01a0001b79818f7011a000249f0192710011a0002155e19052e011903e81a000249f01903e8011a000249f018201a000249f018201a000249f0182001011a000249f0011a000249f0041a000194af18f8011a000194af18f8011a0002377c190556011a0002bdea1901f1011a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000242201a00067e23187600010119f04c192bd200011a000249f018201a000242201a00067e2318760001011a000242201a00067e2318760001011a0025cea81971f704001a000141bb041a000249f019138800011a000249f018201a000302590001011a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a00330da70101ff"
  },
  BABBAGE: {
    V1: "a141005901b69f1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a009063b91903fd0aff",
    V2: "a20198af1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a0011b22c1a0005fdde00021a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201b00000004a817c8001b00000004a817c8001a009063b91903fd0a1b00000004a817c800001b00000004a817c80041005901b69f1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a009063b91903fd0aff"
  }
};
a.NetworkInfo.testnet().network_id() + "", a.NetworkInfo.mainnet().network_id() + "";
const qt = [
  "begin",
  "eternl",
  "flint",
  "nami",
  "nufi",
  "gerowallet",
  "typhoncip30"
], nt = (s) => a.Address.from_bytes(g(s)), Le = (s) => a.Bip32PrivateKey.from_bytes(g(s)), qe = (s) => a.DataHash.from_bytes(g(s)), K = (s) => a.Ed25519KeyHash.from_bytes(g(s)), ft = (s) => a.NativeScript.from_bytes(g(s)), ze = (s) => a.PlutusData.from_bytes(g(s)), wt = (s, e) => a.PlutusScript.from_bytes_with_version(g(s), bt[e]), $e = (s) => a.ScriptRef.from_bytes(g(s)), Je = (s) => a.ScriptHash.from_bytes(g(s)), q = (s) => a.Transaction.from_bytes(g(s)), fe = (s) => a.TransactionHash.from_bytes(g(s)), zt = (s) => a.TransactionUnspentOutput.from_bytes(g(s)), We = (s) => a.TransactionWitnessSet.from_bytes(g(s)), je = (s) => a.Value.from_bytes(g(s)), U = (s) => a.Address.from_bech32(s), kt = (s) => a.BaseAddress.from_address(U(s)), Ce = (s) => a.EnterpriseAddress.from_address(U(s)), _e = (s) => a.RewardAddress.from_address(U(s)), W = (s) => Buffer.from(s).toString("hex"), g = (s) => s.length % 2 === 0 && /^[0-9A-F]*$/i.test(s) ? Buffer.from(s, "hex") : Buffer.from(s, "utf-8"), Ft = (s) => {
  const e = (t) => {
    const r = new Array();
    for (let i = 0; i < t.len(); i += 1)
      r.push(Ft(t.get(i)));
    return r;
  };
  switch (s.kind()) {
    case a.NativeScriptKind.ScriptAll: {
      const t = s.as_script_all();
      return {
        type: "all",
        scripts: e(t.native_scripts())
      };
    }
    case a.NativeScriptKind.ScriptAny: {
      const t = s.as_script_any();
      return {
        type: "any",
        scripts: e(t.native_scripts())
      };
    }
    case a.NativeScriptKind.ScriptNOfK: {
      const t = s.as_script_n_of_k();
      return {
        type: "atLeast",
        required: t.n(),
        scripts: e(t.native_scripts())
      };
    }
    case a.NativeScriptKind.TimelockStart: {
      const t = s.as_timelock_start();
      return {
        type: "after",
        slot: t.slot_bignum().to_str()
      };
    }
    case a.NativeScriptKind.TimelockExpiry: {
      const t = s.as_timelock_expiry();
      return {
        type: "before",
        slot: t.slot_bignum().to_str()
      };
    }
    case a.NativeScriptKind.ScriptPubkey: {
      const t = s.as_script_pubkey();
      return {
        type: "sig",
        keyHash: t.addr_keyhash().to_hex()
      };
    }
    default:
      throw new Error(`Script Kind: ${s.kind()}, is not supported`);
  }
}, Bt = (s) => {
  const e = (t) => {
    const r = a.NativeScripts.new();
    return t.forEach((i) => {
      r.add(Bt(i));
    }), r;
  };
  switch (s.type) {
    case "all":
      return a.NativeScript.new_script_all(a.ScriptAll.new(e(s.scripts)));
    case "any":
      return a.NativeScript.new_script_any(a.ScriptAny.new(e(s.scripts)));
    case "atLeast":
      return a.NativeScript.new_script_n_of_k(a.ScriptNOfK.new(s.required, e(s.scripts)));
    case "after":
      return a.NativeScript.new_timelock_start(a.TimelockStart.new_timelockstart(a.BigNum.from_str(s.slot)));
    case "before":
      return a.NativeScript.new_timelock_expiry(a.TimelockExpiry.new_timelockexpiry(a.BigNum.from_str(s.slot)));
    case "sig":
      return a.NativeScript.new_script_pubkey(a.ScriptPubkey.new(K(s.keyHash)));
  }
}, J = (s) => {
  const e = (t) => {
    const r = a.PlutusList.new();
    return t.forEach((i) => {
      r.add(J(i));
    }), r;
  };
  switch (typeof s) {
    case "string":
      return a.PlutusData.new_bytes(g(s));
    case "number":
      return a.PlutusData.new_integer(a.BigInt.from_str(s.toString()));
    case "object":
      if (s instanceof Array) {
        const t = e(s);
        return a.PlutusData.new_list(t);
      } else if (s instanceof Map) {
        const t = a.PlutusMap.new();
        return s.forEach((r, i) => {
          t.insert(J(i), J(r));
        }), a.PlutusData.new_map(t);
      } else
        return a.PlutusData.new_constr_plutus_data(a.ConstrPlutusData.new(a.BigNum.from_str(s.alternative.toString()), e(s.fields)));
  }
}, Xe = (s) => {
  const e = a.Relays.new();
  throw s.relays.forEach((t) => {
    e.add(ts(t));
  }), new Error("toPoolParams not implemented.");
}, Ze = (s) => {
  const e = (t) => Ge[t];
  return a.Redeemer.new(e(s.tag), a.BigNum.from_str(s.index.toString()), J(s.data), a.ExUnits.new(a.BigNum.from_str(s.budget.mem.toString()), a.BigNum.from_str(s.budget.steps.toString())));
}, ts = (s) => {
  switch (s.type) {
    case "SingleHostAddr": {
      const e = s.IPV4 ? a.Ipv4.new(new Uint8Array(s.IPV4.split(".").map((r) => parseInt(r)))) : void 0, t = s.IPV6 ? a.Ipv6.new(g(s.IPV6.replaceAll(":", ""))) : void 0;
      return a.Relay.new_single_host_addr(a.SingleHostAddr.new(s.port, e, t));
    }
    case "SingleHostName":
      return a.Relay.new_single_host_name(a.SingleHostName.new(s.port, a.DNSRecordAorAAAA.new(s.domainName)));
    case "MultiHostName":
      return a.Relay.new_multi_host_name(a.MultiHostName.new(a.DNSRecordSRV.new(s.domainName)));
  }
}, es = (s) => {
  if (s.is_plutus_script()) {
    const t = s.plutus_script();
    return {
      code: t.to_hex(),
      version: Object.keys(bt).find((r) => bt[r].to_hex() === t.language_version().to_hex())
    };
  }
  const e = s.native_script();
  return Ft(e);
}, Qt = (s) => {
  if ("code" in s) {
    const e = wt(s.code, s.version);
    return a.ScriptRef.new_plutus_script(e);
  }
  return a.ScriptRef.new_native_script(Bt(s));
}, Et = (s) => {
  var i, n, o;
  const e = s.output().has_data_hash() ? (i = s.output().data_hash()) == null ? void 0 : i.to_hex() : void 0, t = s.output().has_plutus_data() ? (n = s.output().plutus_data()) == null ? void 0 : n.to_hex() : void 0, r = s.output().has_script_ref() ? (o = s.output().script_ref()) == null ? void 0 : o.to_hex() : void 0;
  return {
    input: {
      outputIndex: s.input().index(),
      txHash: s.input().transaction_id().to_hex()
    },
    output: {
      address: s.output().address().to_bech32(),
      amount: pe(s.output().amount()),
      dataHash: e,
      plutusData: t,
      scriptRef: r
    }
  };
}, R = (s) => {
  const e = a.TransactionInput.new(fe(s.input.txHash), s.input.outputIndex), t = a.TransactionOutput.new(U(s.output.address), Ct(s.output.amount));
  return s.output.dataHash !== void 0 && t.set_data_hash(qe(s.output.dataHash)), s.output.plutusData !== void 0 && t.set_plutus_data(ze(s.output.plutusData)), s.output.scriptRef !== void 0 && t.set_script_ref($e(s.output.scriptRef)), a.TransactionUnspentOutput.new(e, t);
}, $t = (s) => {
  const e = s.split(".")[1] ?? "0", t = `${parseInt(e, 10)}`, r = "1" + "0".repeat(e.length);
  return a.UnitInterval.new(a.BigNum.from_str(t), a.BigNum.from_str(r));
}, j = (s) => s.length % 2 === 0 && /^[0-9A-F]*$/i.test(s) ? s : W(Buffer.from(s, "utf-8")), ss = (s) => Buffer.from(s, "hex").toString("utf-8"), pe = (s) => {
  const e = [
    { unit: "lovelace", quantity: s.coin().to_str() }
  ], t = s.multiasset();
  if (t !== void 0) {
    const r = t.keys();
    for (let i = 0; i < r.len(); i += 1) {
      const n = r.get(i), o = t.get(n);
      if (o !== void 0) {
        const c = o.keys();
        for (let A = 0; A < c.len(); A += 1) {
          const u = c.get(A), I = o.get(u) ?? a.BigNum.from_str("0"), h = n.to_hex() + W(u.name());
          e.push({ unit: h, quantity: I.to_str() });
        }
      }
    }
  }
  return e;
}, Ct = (s) => {
  const e = s.find((n) => n.unit === "lovelace"), t = Array.from(new Set(s.filter((n) => n.unit !== "lovelace").map((n) => n.unit.slice(0, L)))), r = a.MultiAsset.new();
  t.forEach((n) => {
    const o = a.Assets.new();
    s.filter((c) => c.unit.slice(0, L) === n).forEach((c) => {
      o.insert(a.AssetName.new(g(c.unit.slice(L))), a.BigNum.from_str(c.quantity));
    }), r.insert(Je(n), o);
  });
  const i = a.Value.new(a.BigNum.from_str(e ? e.quantity : "0"));
  return (s.length > 1 || !e) && i.set_multiasset(r), i;
}, Jt = (s, e, t) => a.BaseAddress.new(s, a.StakeCredential.from_keyhash(e), a.StakeCredential.from_keyhash(t)), we = (s, e = "") => a.Bip32PrivateKey.from_bip39_entropy(g(s), g(j(e))), Wt = (s) => a.DataCost.new_coins_per_byte(a.BigNum.from_str(s)), rs = (s) => {
  if (typeof s != "object" || !("input" in s))
    return a.DatumSource.new(J(s));
  const e = R(s);
  if (e.output().has_plutus_data())
    return a.DatumSource.new_ref_input(e.input());
  throw new Error(`No inline datum found in UTxO: ${e.input().transaction_id().to_hex()}`);
}, jt = (s, e) => a.EnterpriseAddress.new(s, a.StakeCredential.from_keyhash(e)), Kt = (s, e) => a.RewardAddress.new(s, a.StakeCredential.from_keyhash(e)), is = (s) => {
  if ("code" in s)
    return a.PlutusScriptSource.new(wt(s.code, s.version));
  const e = R(s);
  if (e.output().has_script_ref()) {
    const t = e.output().script_ref();
    if (t.is_plutus_script()) {
      const r = es(t), i = wt(r.code, r.version).hash();
      return a.PlutusScriptSource.new_ref_input(i, e.input());
    }
  }
  throw new Error(`No plutus script reference found in UTxO: ${e.input().transaction_id().to_hex()}`);
}, ht = (s) => {
  const e = a.ScriptPubkey.new(s);
  return a.NativeScript.new_script_pubkey(e);
}, as = (s = P) => {
  const e = a.TransactionBuilderConfigBuilder.new().coins_per_utxo_byte(a.BigNum.from_str(s.coinsPerUTxOSize)).ex_unit_prices(a.ExUnitPrices.new($t(s.priceMem.toString()), $t(s.priceStep.toString()))).fee_algo(a.LinearFee.new(a.BigNum.from_str(s.minFeeA.toString()), a.BigNum.from_str(s.minFeeB.toString()))).key_deposit(a.BigNum.from_str(s.keyDeposit)).max_tx_size(s.maxTxSize).max_value_size(parseInt(s.maxValSize, 10)).pool_deposit(a.BigNum.from_str(s.poolDeposit)).build();
  return a.TransactionBuilder.new(e);
}, Xt = (s) => {
  const e = a.TxInputsBuilder.new();
  return s.map((t) => t instanceof a.TransactionUnspentOutput ? t : R(t)).forEach((t) => {
    e.add_input(t.output().address(), t.input(), t.output().amount());
  }), e;
}, ut = (s) => {
  if (typeof s == "string")
    return a.TransactionOutputBuilder.new().with_address(U(s));
  let e = a.TransactionOutputBuilder.new().with_address(U(s.address));
  if (s.datum) {
    const { value: t, inline: r } = s.datum, i = J(t);
    e = e.with_data_hash(a.hash_plutus_data(i)), r && (e = e.with_plutus_data(i));
  }
  if (s.script) {
    const t = Qt(s.script);
    e = e.with_script_ref(t);
  }
  return e;
}, C = (s) => it.isAxiosError(s) ? s.response ? JSON.stringify({
  data: s.response.data,
  headers: s.response.headers,
  status: s.response.status
}) : s.request ? JSON.stringify(s.request) : s.message : JSON.stringify(s), ns = (s, e, t = !1, { maxTxSize: r, minFeeA: i, minFeeB: n } = P) => {
  const o = e.filter((h) => ye(h) === !1).sort(Ee), c = a.BigNum.from_str(Ue(r, i, n)), A = t ? a.BigNum.from_str(s).checked_add(c).to_str() : s;
  return yt(o, /* @__PURE__ */ new Map([
    ["lovelace", A]
  ]));
}, os = (s, e, t = !1, r = P) => {
  const i = e.filter(ye).sort(Ee), n = s.get("lovelace") ?? "0", { maxTxSize: o, minFeeA: c, minFeeB: A } = r, u = a.BigNum.from_str(Ue(o, c, A)), I = t ? a.BigNum.from_str(n).checked_add(u).to_str() : n;
  return s.set("lovelace", I), yt(i, s);
}, As = (s, e) => Array.from(e, (t) => ({ unit: t[0], quantity: a.BigNum.from_str(t[1]) })).every((t) => s.filter((r) => r.output.amount.find((i) => i.unit === t.unit) !== void 0).reduce((r, i) => {
  const n = i.output.amount.reduce((o, c) => o.checked_add(a.BigNum.from_str(c.quantity)), a.BigNum.from_str("0"));
  return r.checked_add(n);
}, a.BigNum.from_str("0")).less_than(t.quantity) === !1), Ee = (s, e) => {
  var i, n;
  const t = a.BigNum.from_str(((i = s.output.amount.find((o) => o.unit === "lovelace")) == null ? void 0 : i.quantity) ?? "0");
  return a.BigNum.from_str(((n = e.output.amount.find((o) => o.unit === "lovelace")) == null ? void 0 : n.quantity) ?? "0").compare(t);
}, ye = (s) => s.output.amount.length > 1, yt = (s, e, t = []) => s.length === 0 || As(t, e) ? t : cs(s[0], e) ? yt(s.slice(1), e, [...t, s[0]]) : yt(s.slice(1), e, t), cs = (s, e) => Array.from(e.keys()).some((t) => s.output.amount.find((r) => r.unit === t) !== void 0), Is = (s, e) => {
  const t = hs(e), r = us(s, e);
  return {
    coseKey: W(t.to_bytes()),
    coseSign1: W(r.to_bytes())
  };
}, hs = (s) => {
  const e = Ne.new(Z.from_key_type(Pe.OKP));
  return e.set_algorithm_id(Z.from_algorithm_id(ge.EdDSA)), e.set_header(Z.new_int(xt.new_negative(Gt.from_str("1"))), vt.new_int(xt.new_i32(6))), e.set_header(Z.new_int(xt.new_negative(Gt.from_str("2"))), vt.new_bytes(s.key.to_public().as_bytes())), e;
}, us = (s, e) => {
  const t = Rt.new(), r = Rt.new();
  t.set_algorithm_id(Z.from_algorithm_id(ge.EdDSA)), t.set_header(Z.new_text("address"), vt.new_bytes(e.address.to_bytes()));
  const i = Me.new(Te.new(t), r), n = Ve.new(i, g(s.payload), !1);
  s.externalAAD !== void 0 && n.set_external_aad(g(s.externalAAD));
  const o = n.make_data_to_sign(), c = e.key.sign(o.to_bytes());
  return n.build(c.to_bytes());
};
var Zt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, me = {}, B = { exports: {} };
M.notEqual = ls;
M.notOk = gs;
M.equal = ds;
M.ok = M;
var Be = M;
function ds(s, e, t) {
  M(s == e, t);
}
function ls(s, e, t) {
  M(s != e, t);
}
function gs(s, e) {
  M(!s, e);
}
function M(s, e) {
  if (!s)
    throw new Error(e || "AssertionError");
}
var k = { exports: {} };
function fs(s) {
  throw new Error('Could not dynamically require "' + s + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Cs = Ht;
Ht.supported = typeof WebAssembly < "u";
function Ht(s) {
  if (!Ht.supported)
    return null;
  var e = s && s.imports, t = _s("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0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"), r = null, i = {
    buffer: t,
    memory: null,
    exports: null,
    realloc: n,
    onload: o
  };
  return o(function() {
  }), i;
  function n(A) {
    i.exports.memory.grow(Math.ceil(Math.abs(A - i.memory.length) / 65536)), i.memory = new Uint8Array(i.exports.memory.buffer);
  }
  function o(A) {
    if (i.exports)
      return A();
    if (r) {
      r.then(A.bind(null, null)).catch(A);
      return;
    }
    try {
      if (s && s.async)
        throw new Error("async");
      c({ instance: new WebAssembly.Instance(new WebAssembly.Module(t), e) });
    } catch {
      r = WebAssembly.instantiate(t, e).then(c);
    }
    o(A);
  }
  function c(A) {
    i.exports = A.instance.exports, i.memory = i.exports.memory && i.exports.memory.buffer && new Uint8Array(i.exports.memory.buffer);
  }
}
function _s(s) {
  return typeof atob == "function" ? new Uint8Array(atob(s).split("").map(ps)) : new (fs("buffer")).Buffer(s, "base64");
}
function ps(s) {
  return s.charCodeAt(0);
}
var b = Be, f = Cs(), N = 64, _t = [];
k.exports = Q;
var te = k.exports.BYTES_MIN = 16, ee = k.exports.BYTES_MAX = 64;
k.exports.BYTES = 32;
var se = k.exports.KEYBYTES_MIN = 16, re = k.exports.KEYBYTES_MAX = 64;
k.exports.KEYBYTES = 32;
var ie = k.exports.SALTBYTES = 16, ae = k.exports.PERSONALBYTES = 16;
function Q(s, e, t, r, i) {
  if (!(this instanceof Q))
    return new Q(s, e, t, r, i);
  if (!(f && f.exports))
    throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)");
  s || (s = 32), i !== !0 && (b(s >= te, "digestLength must be at least " + te + ", was given " + s), b(s <= ee, "digestLength must be at most " + ee + ", was given " + s), e != null && b(e.length >= se, "key must be at least " + se + ", was given " + e.length), e != null && b(e.length <= re, "key must be at least " + re + ", was given " + e.length), t != null && b(t.length === ie, "salt must be exactly " + ie + ", was given " + t.length), r != null && b(r.length === ae, "personal must be exactly " + ae + ", was given " + r.length)), _t.length || (_t.push(N), N += 216), this.digestLength = s, this.finalized = !1, this.pointer = _t.pop(), f.memory.fill(0, 0, 64), f.memory[0] = this.digestLength, f.memory[1] = e ? e.length : 0, f.memory[2] = 1, f.memory[3] = 1, t && f.memory.set(t, 32), r && f.memory.set(r, 48), this.pointer + 216 > f.memory.length && f.realloc(this.pointer + 216), f.exports.blake2b_init(this.pointer, this.digestLength), e && (this.update(e), f.memory.fill(0, N, N + e.length), f.memory[this.pointer + 200] = 128);
}
Q.prototype.update = function(s) {
  return b(this.finalized === !1, "Hash instance finalized"), b(s, "input must be TypedArray or Buffer"), N + s.length > f.memory.length && f.realloc(N + s.length), f.memory.set(s, N), f.exports.blake2b_update(this.pointer, N, N + s.length), this;
};
Q.prototype.digest = function(s) {
  if (b(this.finalized === !1, "Hash instance finalized"), this.finalized = !0, _t.push(this.pointer), f.exports.blake2b_final(this.pointer), !s || s === "binary")
    return f.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
  if (s === "hex")
    return Es(f.memory, this.pointer + 128, this.digestLength);
  b(s.length >= this.digestLength, "input must be TypedArray or Buffer");
  for (var e = 0; e < this.digestLength; e++)
    s[e] = f.memory[this.pointer + 128 + e];
  return s;
};
Q.prototype.final = Q.prototype.digest;
Q.WASM = f && f.buffer;
Q.SUPPORTED = typeof WebAssembly < "u";
Q.ready = function(s) {
  if (s || (s = ws), !f)
    return s(new Error("WebAssembly not supported"));
  var e = new Promise(function(t, r) {
    f.onload(function(i) {
      i ? r() : t(), s(i);
    });
  });
  return e;
};
Q.prototype.ready = Q.ready;
function ws() {
}
function Es(s, e, t) {
  for (var r = "", i = 0; i < t; i++)
    r += ys(s[e + i]);
  return r;
}
function ys(s) {
  return s < 16 ? "0" + s.toString(16) : s.toString(16);
}
var G = Be, ct = k.exports;
function dt(s, e, t) {
  var r = s[e] + s[t], i = s[e + 1] + s[t + 1];
  r >= 4294967296 && i++, s[e] = r, s[e + 1] = i;
}
function ne(s, e, t, r) {
  var i = s[e] + t;
  t < 0 && (i += 4294967296);
  var n = s[e + 1] + r;
  i >= 4294967296 && n++, s[e] = i, s[e + 1] = n;
}
function Qe(s, e) {
  return s[e] ^ s[e + 1] << 8 ^ s[e + 2] << 16 ^ s[e + 3] << 24;
}
function O(s, e, t, r, i, n) {
  var o = ot[i], c = ot[i + 1], A = ot[n], u = ot[n + 1];
  dt(d, s, e), ne(d, s, o, c);
  var I = d[r] ^ d[s], h = d[r + 1] ^ d[s + 1];
  d[r] = h, d[r + 1] = I, dt(d, t, r), I = d[e] ^ d[t], h = d[e + 1] ^ d[t + 1], d[e] = I >>> 24 ^ h << 8, d[e + 1] = h >>> 24 ^ I << 8, dt(d, s, e), ne(d, s, A, u), I = d[r] ^ d[s], h = d[r + 1] ^ d[s + 1], d[r] = I >>> 16 ^ h << 16, d[r + 1] = h >>> 16 ^ I << 16, dt(d, t, r), I = d[e] ^ d[t], h = d[e + 1] ^ d[t + 1], d[e] = h >>> 31 ^ I << 1, d[e + 1] = I >>> 31 ^ h << 1;
}
var xe = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]), ms = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
], y = new Uint8Array(ms.map(function(s) {
  return s * 2;
})), d = new Uint32Array(32), ot = new Uint32Array(32);
function Se(s, e) {
  var t = 0;
  for (t = 0; t < 16; t++)
    d[t] = s.h[t], d[t + 16] = xe[t];
  for (d[24] = d[24] ^ s.t, d[25] = d[25] ^ s.t / 4294967296, e && (d[28] = ~d[28], d[29] = ~d[29]), t = 0; t < 32; t++)
    ot[t] = Qe(s.b, 4 * t);
  for (t = 0; t < 12; t++)
    O(0, 8, 16, 24, y[t * 16 + 0], y[t * 16 + 1]), O(2, 10, 18, 26, y[t * 16 + 2], y[t * 16 + 3]), O(4, 12, 20, 28, y[t * 16 + 4], y[t * 16 + 5]), O(6, 14, 22, 30, y[t * 16 + 6], y[t * 16 + 7]), O(0, 10, 20, 30, y[t * 16 + 8], y[t * 16 + 9]), O(2, 12, 22, 24, y[t * 16 + 10], y[t * 16 + 11]), O(4, 14, 16, 26, y[t * 16 + 12], y[t * 16 + 13]), O(6, 8, 18, 28, y[t * 16 + 14], y[t * 16 + 15]);
  for (t = 0; t < 16; t++)
    s.h[t] = s.h[t] ^ d[t] ^ d[t + 16];
}
var Y = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function st(s, e, t, r) {
  Y.fill(0), this.b = new Uint8Array(128), this.h = new Uint32Array(16), this.t = 0, this.c = 0, this.outlen = s, Y[0] = s, e && (Y[1] = e.length), Y[2] = 1, Y[3] = 1, t && Y.set(t, 32), r && Y.set(r, 48);
  for (var i = 0; i < 16; i++)
    this.h[i] = xe[i] ^ Qe(Y, i * 4);
  e && (De(this, e), this.c = 128);
}
st.prototype.update = function(s) {
  return G(s != null, "input must be Uint8Array or Buffer"), De(this, s), this;
};
st.prototype.digest = function(s) {
  var e = !s || s === "binary" || s === "hex" ? new Uint8Array(this.outlen) : s;
  return G(e.length >= this.outlen, "out must have at least outlen bytes of space"), Bs(this, e), s === "hex" ? Qs(e) : e;
};
st.prototype.final = st.prototype.digest;
st.ready = function(s) {
  ct.ready(function() {
    s();
  });
};
function De(s, e) {
  for (var t = 0; t < e.length; t++)
    s.c === 128 && (s.t += s.c, Se(s, !1), s.c = 0), s.b[s.c++] = e[t];
}
function Bs(s, e) {
  for (s.t += s.c; s.c < 128; )
    s.b[s.c++] = 0;
  Se(s, !0);
  for (var t = 0; t < s.outlen; t++)
    e[t] = s.h[t >> 2] >> 8 * (t & 3);
  return e;
}
function Qs(s) {
  for (var e = "", t = 0; t < s.length; t++)
    e += xs(s[t]);
  return e;
}
function xs(s) {
  return s < 16 ? "0" + s.toString(16) : s.toString(16);
}
var ve = st;
B.exports = function(e, t, r, i, n) {
  return n !== !0 && (G(e >= oe, "outlen must be at least " + oe + ", was given " + e), G(e <= Ae, "outlen must be at most " + Ae + ", was given " + e), t != null && G(t.length >= ce, "key must be at least " + ce + ", was given " + t.length), t != null && G(t.length <= Ie, "key must be at most " + Ie + ", was given " + t.length), r != null && G(r.length === he, "salt must be exactly " + he + ", was given " + r.length), i != null && G(i.length === ue, "personal must be exactly " + ue + ", was given " + i.length)), new ve(e, t, r, i);
};
B.exports.ready = function(s) {
  ct.ready(function() {
    s();
  });
};
B.exports.WASM_SUPPORTED = ct.SUPPORTED;
B.exports.WASM_LOADED = !1;
var oe = B.exports.BYTES_MIN = 16, Ae = B.exports.BYTES_MAX = 64;
B.exports.BYTES = 32;
var ce = B.exports.KEYBYTES_MIN = 16, Ie = B.exports.KEYBYTES_MAX = 64;
B.exports.KEYBYTES = 32;
var he = B.exports.SALTBYTES = 16, ue = B.exports.PERSONALBYTES = 16;
ct.ready(function(s) {
  s || (B.exports.WASM_LOADED = !0, ve = ct);
});
var rt = {};
Object.defineProperty(rt, "__esModule", { value: !0 });
rt.bech32m = rt.bech32 = void 0;
const mt = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", be = {};
for (let s = 0; s < mt.length; s++) {
  const e = mt.charAt(s);
  be[e] = s;
}
function et(s) {
  const e = s >> 25;
  return (s & 33554431) << 5 ^ -(e >> 0 & 1) & 996825010 ^ -(e >> 1 & 1) & 642813549 ^ -(e >> 2 & 1) & 513874426 ^ -(e >> 3 & 1) & 1027748829 ^ -(e >> 4 & 1) & 705979059;
}
function de(s) {
  let e = 1;
  for (let t = 0; t < s.length; ++t) {
    const r = s.charCodeAt(t);
    if (r < 33 || r > 126)
      return "Invalid prefix (" + s + ")";
    e = et(e) ^ r >> 5;
  }
  e = et(e);
  for (let t = 0; t < s.length; ++t) {
    const r = s.charCodeAt(t);
    e = et(e) ^ r & 31;
  }
  return e;
}
function Nt(s, e, t, r) {
  let i = 0, n = 0;
  const o = (1 << t) - 1, c = [];
  for (let A = 0; A < s.length; ++A)
    for (i = i << e | s[A], n += e; n >= t; )
      n -= t, c.push(i >> n & o);
  if (r)
    n > 0 && c.push(i << t - n & o);
  else {
    if (n >= e)
      return "Excess padding";
    if (i << t - n & o)
      return "Non-zero padding";
  }
  return c;
}
function Ss(s) {
  return Nt(s, 8, 5, !0);
}
function Ds(s) {
  const e = Nt(s, 5, 8, !1);
  if (Array.isArray(e))
    return e;
}
function vs(s) {
  const e = Nt(s, 5, 8, !1);
  if (Array.isArray(e))
    return e;
  throw new Error(e);
}
function Ke(s) {
  let e;
  s === "bech32" ? e = 1 : e = 734539939;
  function t(o, c, A) {
    if (A = A || 90, o.length + 7 + c.length > A)
      throw new TypeError("Exceeds length limit");
    o = o.toLowerCase();
    let u = de(o);
    if (typeof u == "string")
      throw new Error(u);
    let I = o + "1";
    for (let h = 0; h < c.length; ++h) {
      const _ = c[h];
      if (_ >> 5 !== 0)
        throw new Error("Non 5-bit word");
      u = et(u) ^ _, I += mt.charAt(_);
    }
    for (let h = 0; h < 6; ++h)
      u = et(u);
    u ^= e;
    for (let h = 0; h < 6; ++h) {
      const _ = u >> (5 - h) * 5 & 31;
      I += mt.charAt(_);
    }
    return I;
  }
  function r(o, c) {
    if (c = c || 90, o.length < 8)
      return o + " too short";
    if (o.length > c)
      return "Exceeds length limit";
    const A = o.toLowerCase(), u = o.toUpperCase();
    if (o !== A && o !== u)
      return "Mixed-case string " + o;
    o = A;
    const I = o.lastIndexOf("1");
    if (I === -1)
      return "No separator character for " + o;
    if (I === 0)
      return "Missing prefix for " + o;
    const h = o.slice(0, I), _ = o.slice(I + 1);
    if (_.length < 6)
      return "Data too short";
    let D = de(h);
    if (typeof D == "string")
      return D;
    const $ = [];
    for (let F = 0; F < _.length; ++F) {
      const V = _.charAt(F), l = be[V];
      if (l === void 0)
        return "Unknown character " + V;
      D = et(D) ^ l, !(F + 6 >= _.length) && $.push(l);
    }
    return D !== e ? "Invalid checksum for " + o : { prefix: h, words: $ };
  }
  function i(o, c) {
    const A = r(o, c);
    if (typeof A == "object")
      return A;
  }
  function n(o, c) {
    const A = r(o, c);
    if (typeof A == "object")
      return A;
    throw new Error(A);
  }
  return {
    decodeUnsafe: i,
    decode: n,
    encode: t,
    toWords: Ss,
    fromWordsUnsafe: Ds,
    fromWords: vs
  };
}
rt.bech32 = Ke("bech32");
rt.bech32m = Ke("bech32m");
var bs = Zt && Zt.__importDefault || function(s) {
  return s && s.__esModule ? s : { default: s };
};
Object.defineProperty(me, "__esModule", { value: !0 });
const Ks = bs(B.exports), lt = rt, Dt = "asset";
class At {
  constructor(e) {
    this.hashBuf = e;
  }
  static fromHash(e) {
    return new At(e);
  }
  static fromParts(e, t) {
    const r = (0, Ks.default)(20).update(new Uint8Array([...e, ...t])).digest("binary");
    return At.fromHash(r);
  }
  static fromBech32(e) {
    const { prefix: t, words: r } = lt.bech32.decode(e);
    if (t !== Dt)
      throw new Error("Invalid asset fingerprint");
    const i = Buffer.from(lt.bech32.fromWords(r));
    return At.fromHash(i);
  }
  fingerprint() {
    const e = lt.bech32.toWords(this.hashBuf);
    return lt.bech32.encode(Dt, e);
  }
  hash() {
    return Buffer.from(this.hashBuf).toString("hex");
  }
  prefix() {
    return Dt;
  }
  checksum() {
    return this.fingerprint().slice(-6);
  }
}
var Us = me.default = At;
const ks = Us, Fs = (s, e) => {
  const t = Le(s), r = t.derive(St + 1852).derive(St + 1815).derive(St + e), i = r.derive(0).derive(0).to_raw_key(), n = r.derive(2).derive(0).to_raw_key();
  return r.free(), t.free(), { paymentKey: i, stakeKey: n };
}, Ls = (s) => {
  const e = J(s);
  return a.hash_plutus_data(e).to_hex();
}, qs = (s, e = Date.now()) => {
  if (pt[s]) {
    const [t, r, i, n] = pt[s];
    return parseInt(a.BigNum.from_str(e.toString()).div_floor(a.BigNum.from_str("1000")).checked_sub(a.BigNum.from_str(i)).div_floor(a.BigNum.from_str(n)).checked_add(a.BigNum.from_str(t)).to_str(), 10);
  }
  throw new Error(`Couldn't resolve EpochNo for network: ${s}`);
}, Hs = (s, e) => ks.fromParts(g(s), g(e)).fingerprint(), zs = (s, e) => Re[s][e], $s = (s) => Bt(s).hash().to_hex(), tt = (s) => {
  var e, t;
  try {
    const r = [
      (e = kt(s)) == null ? void 0 : e.payment_cred().to_keyhash(),
      (t = Ce(s)) == null ? void 0 : t.payment_cred().to_keyhash()
    ].find((i) => i !== void 0);
    if (r !== void 0)
      return r.to_hex();
    throw new Error(`Couldn't resolve payment key hash from address: ${s}`);
  } catch (r) {
    throw new Error(`An error occurred during resolvePaymentKeyHash: ${r}.`);
  }
}, Js = (s, e = 0) => {
  const t = wt(s.code, s.version);
  return a.EnterpriseAddress.new(e, a.StakeCredential.from_scripthash(t.hash())).to_address().to_bech32();
}, Ws = (s) => {
  try {
    const e = Ce(s), t = e == null ? void 0 : e.payment_cred().to_scripthash();
    if (t !== void 0)
      return t.to_hex();
    throw new Error(`Couldn't resolve script hash from address: ${s}`);
  } catch (e) {
    throw new Error(`An error occurred during resolveScriptHash: ${e}.`);
  }
}, js = (s) => a.Ed25519KeyHash.from_hex(s).to_bech32("pool1"), Xs = (s) => {
  const e = le(s.join(" ")), t = we(e), r = t.to_bech32();
  return t.free(), r;
}, Zs = (s) => Qt(s).to_hex(), tr = (s, e = Date.now()) => {
  if (pt[s]) {
    const [t, r, i] = pt[s];
    return a.BigNum.from_str(e.toString()).div_floor(a.BigNum.from_str("1000")).checked_sub(a.BigNum.from_str(i)).checked_add(a.BigNum.from_str(r)).to_str();
  }
  throw new Error(`Couldn't resolve SlotNo for network: ${s}`);
}, Pt = (s) => {
  try {
    const e = U(s), t = kt(s), r = t == null ? void 0 : t.stake_cred().to_keyhash();
    if (r !== void 0)
      return Kt(e.network_id(), r).to_address().to_bech32();
    throw new Error(`Couldn't resolve reward address from address: ${s}`);
  } catch (e) {
    throw new Error(`An error occurred during resolveRewardAddress: ${e}.`);
  }
}, gt = (s) => {
  var e, t;
  try {
    const r = [
      (e = kt(s)) == null ? void 0 : e.stake_cred().to_keyhash(),
      (t = _e(s)) == null ? void 0 : t.payment_cred().to_keyhash()
    ].find((i) => i !== void 0);
    if (r !== void 0)
      return r.to_hex();
    throw new Error(`Couldn't resolve stake key hash from address: ${s}`);
  } catch (r) {
    throw new Error(`An error occurred during resolveStakeKeyHash: ${r}.`);
  }
}, Ue = (s, e = P.minFeeA, t = P.minFeeB) => (BigInt(e) * BigInt(s) + BigInt(t)).toString(), Ns = (s) => {
  const e = q(s).body();
  return a.hash_transaction(e).to_hex();
};
class er {
  _axiosInstance;
  constructor(e, t = 0) {
    const r = e.slice(0, 7);
    this._axiosInstance = it.create({
      baseURL: `https://cardano-${r}.blockfrost.io/api/v${t}`,
      headers: { project_id: e }
    });
  }
  async fetchAccountInfo(e) {
    const t = e.startsWith("addr") ? Pt(e) : e;
    try {
      const { data: r, status: i } = await this._axiosInstance.get(`accounts/${t}`);
      if (i === 200)
        return {
          active: r.active || r.active_epoch !== null,
          poolId: r.pool_id,
          balance: r.controlled_amount,
          rewards: r.withdrawable_amount,
          withdrawals: r.withdrawals_sum
        };
      throw C(r);
    } catch (r) {
      throw C(r);
    }
  }
  async fetchAddressUTxOs(e, t) {
    const r = t !== void 0 ? `/${t}` : "", i = `addresses/${e}/utxos` + r, n = async (A = 1, u = []) => {
      const { data: I, status: h } = await this._axiosInstance.get(`${i}?page=${A}`);
      if (h === 200)
        return I.length > 0 ? n(A + 1, [...u, ...await Promise.all(I.map(c))]) : u;
      throw C(I);
    }, o = async (A) => {
      if (A) {
        const { data: u, status: I } = await this._axiosInstance.get(`scripts/${A}`);
        if (I === 200) {
          const h = u.type.startsWith("plutus") ? {
            code: await this.fetchPlutusScriptCBOR(A),
            version: u.type.replace("plutus", "")
          } : await this.fetchNativeScriptJSON(A);
          return Qt(h).to_hex();
        }
        throw C(u);
      }
    }, c = async (A) => ({
      input: {
        outputIndex: A.output_index,
        txHash: A.tx_hash
      },
      output: {
        address: e,
        amount: A.amount,
        dataHash: A.data_hash ?? void 0,
        plutusData: A.inline_datum ?? void 0,
        scriptRef: await o(A.reference_script_hash)
      }
    });
    try {
      return await n();
    } catch {
      return [];
    }
  }
  async fetchAssetMetadata(e) {
    throw new Error("fetchAssetMetadata not implemented.");
  }
  async fetchHandleAddress(e) {
    throw new Error("fetchHandleAddress not implemented.");
  }
  async fetchProtocolParameters(e = Number.NaN) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`epochs/${isNaN(e) ? "latest" : e}/parameters`);
      if (r === 200)
        return {
          coinsPerUTxOSize: t.coins_per_utxo_word,
          collateralPercent: t.collateral_percent,
          decentralisation: t.decentralisation_param,
          epoch: t.epoch,
          keyDeposit: t.key_deposit,
          maxBlockExMem: t.max_block_ex_mem,
          maxBlockExSteps: t.max_block_ex_steps,
          maxBlockHeaderSize: t.max_block_header_size,
          maxBlockSize: t.max_block_size,
          maxCollateralInputs: t.max_collateral_inputs,
          maxTxExMem: t.max_tx_ex_mem,
          maxTxExSteps: t.max_tx_ex_steps,
          maxTxSize: t.max_tx_size,
          maxValSize: t.max_val_size,
          minFeeA: t.min_fee_a,
          minFeeB: t.min_fee_b,
          minPoolCost: t.min_pool_cost,
          poolDeposit: t.pool_deposit,
          priceMem: t.price_mem,
          priceStep: t.price_step
        };
      throw C(t);
    } catch (t) {
      throw C(t);
    }
  }
  async submitTx(e) {
    try {
      const t = { "Content-Type": "application/cbor" }, { data: r, status: i } = await this._axiosInstance.post("tx/submit", g(e), { headers: t });
      if (i === 200)
        return r;
      throw C(r);
    } catch (t) {
      throw C(t);
    }
  }
  async fetchPlutusScriptCBOR(e) {
    const { data: t, status: r } = await this._axiosInstance.get(`scripts/${e}/cbor`);
    if (r === 200)
      return t.cbor;
    throw C(t);
  }
  async fetchNativeScriptJSON(e) {
    const { data: t, status: r } = await this._axiosInstance.get(`scripts/${e}/json`);
    if (r === 200)
      return t.json;
    throw C(t);
  }
}
class sr {
  _axiosInstance;
  constructor(e, t, r) {
    const i = r.host ?? "ipfs.infura.io", n = r.port ?? 5001, o = r.version ?? 0;
    this._axiosInstance = it.create({
      baseURL: `https://${i}:${n}/api/v${o}`,
      auth: { username: e, password: t }
    });
  }
  async uploadContent(e, t = !1) {
    try {
      const r = { "Content-Type": "multipart/form-data" }, { data: i, status: n } = await this._axiosInstance.post(`add?recursive=${t}`, e, { headers: r });
      if (n === 200)
        return i;
      throw C(i);
    } catch (r) {
      throw C(r);
    }
  }
}
class rr {
  _axiosInstance;
  constructor(e, t = 0) {
    this._axiosInstance = it.create({
      baseURL: `https://${e}.koios.rest/api/v${t}`
    });
  }
  async fetchAccountInfo(e) {
    try {
      const t = e.startsWith("addr") ? Pt(e) : e, { data: r, status: i } = await this._axiosInstance.post("account_info", { _stake_addresses: [t] });
      if (i === 200)
        return {
          poolId: r[0].delegated_pool,
          active: r[0].status === "registered",
          balance: r[0].total_balance.toString(),
          rewards: r[0].rewards_available,
          withdrawals: r[0].withdrawals
        };
      throw C(r);
    } catch (t) {
      throw C(t);
    }
  }
  async fetchAddressUTxOs(e, t) {
    const r = (i) => {
      if (i) {
        const n = i.type.startsWith("plutus") ? {
          code: i.bytes,
          version: i.type.replace("plutus", "")
        } : Ft(ft(i.bytes));
        return Qt(n).to_hex();
      }
    };
    try {
      const { data: i, status: n } = await this._axiosInstance.post("address_info", { _addresses: [e] });
      if (n === 200) {
        const o = i.flatMap((c) => c.utxo_set).map((c) => ({
          input: {
            outputIndex: c.tx_index,
            txHash: c.tx_hash
          },
          output: {
            address: e,
            amount: [
              { unit: "lovelace", quantity: c.value },
              ...c.asset_list.map((A) => ({
                unit: `${A.policy_id}${A.asset_name}`,
                quantity: `${A.quantity}`
              }))
            ],
            dataHash: c.datum_hash ?? void 0,
            plutusData: c.inline_datum.bytes ?? void 0,
            scriptRef: r(c.reference_script)
          }
        }));
        return t !== void 0 ? o.filter((c) => c.output.amount.find((A) => A.unit === t) !== void 0) : o;
      }
      throw C(i);
    } catch {
      return [];
    }
  }
  async fetchAssetMetadata(e) {
    throw new Error("fetchAssetMetadata not implemented.");
  }
  async fetchHandleAddress(e) {
    throw new Error("fetchHandleAddress not implemented.");
  }
  async fetchProtocolParameters(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`epoch_params?_epoch_no=${e}`);
      if (r === 200)
        return {
          coinsPerUTxOSize: t[0].coins_per_utxo_size,
          collateralPercent: t[0].collateral_percent,
          decentralisation: t[0].decentralisation,
          epoch: t[0].epoch_no,
          keyDeposit: t[0].key_deposit,
          maxBlockExMem: t[0].max_block_ex_mem.toString(),
          maxBlockExSteps: t[0].max_block_ex_steps.toString(),
          maxBlockHeaderSize: t[0].max_bh_size,
          maxBlockSize: t[0].max_block_size,
          maxCollateralInputs: t[0].max_collateral_inputs,
          maxTxExMem: t[0].max_tx_ex_mem.toString(),
          maxTxExSteps: t[0].max_tx_ex_steps.toString(),
          maxTxSize: t[0].max_tx_size,
          maxValSize: t[0].max_val_size.toString(),
          minFeeA: t[0].min_fee_a,
          minFeeB: t[0].min_fee_b,
          minPoolCost: t[0].min_pool_cost,
          poolDeposit: t[0].pool_deposit,
          priceMem: t[0].price_mem,
          priceStep: t[0].price_step
        };
      throw C(t);
    } catch (t) {
      throw C(t);
    }
  }
  async submitTx(e) {
    try {
      const t = { "Content-Type": "application/cbor" }, { data: r, status: i } = await this._axiosInstance.post("submittx", g(e), { headers: t });
      if (i === 202)
        return r;
      throw C(r);
    } catch (t) {
      throw C(t);
    }
  }
}
class ir {
  _axiosInstance;
  constructor(e, t, r, i = 1) {
    this._axiosInstance = it.create({
      baseURL: `https://cardano-${e}.tangocrypto.com/${t}/v${i}`,
      headers: { "x-api-key": r }
    });
  }
  async fetchAccountInfo(e) {
    try {
      const t = e.startsWith("addr") ? Pt(e) : e, { data: r, status: i } = await this._axiosInstance.get(`wallets/${t}`);
      if (i === 200)
        return {
          poolId: r.pool_id,
          active: r.active,
          balance: r.controlled_total_stake,
          rewards: r.rewards_sum,
          withdrawals: r.withdrawals_sum
        };
      throw C(r);
    } catch (t) {
      throw C(t);
    }
  }
  async fetchAddressUTxOs(e, t) {
    const r = t !== void 0 ? `/assets/${t}` : "", i = `addresses/${e}${r}/utxos?size=50`, n = async (A = "", u = []) => {
      var _;
      const { data: I, status: h } = await this._axiosInstance.get(`${i}&cursor=${A}`);
      if (h === 200)
        return I.cursor !== null && ((_ = I.cursor) == null ? void 0 : _.length) > 0 ? n(I.cursor, [...u, ...I.data.map(c)]) : I.data.map(c);
      throw C(I);
    }, o = (A, u) => {
      const I = [{
        unit: "lovelace",
        quantity: A.toString()
      }];
      return u.forEach((h) => {
        const _ = j(h.asset_name);
        I.push({
          unit: `${h.policy_id}${_}`,
          quantity: h.quantity.toString()
        });
      }), I;
    }, c = (A) => ({
      input: {
        outputIndex: A.index,
        txHash: A.hash
      },
      output: {
        address: e,
        amount: o(A.value, A.assets)
      }
    });
    try {
      return await n();
    } catch {
      return [];
    }
  }
  async fetchAssetMetadata(e) {
    throw new Error("fetchAssetMetadata not implemented.");
  }
  async fetchHandleAddress(e) {
    throw new Error("fetchHandleAddress not implemented.");
  }
  async fetchProtocolParameters(e) {
    try {
      const { data: t, status: r } = await this._axiosInstance.get(`epochs/${e}/parameters`);
      if (r === 200)
        return {
          coinsPerUTxOSize: t.coins_per_utxo_size.toString(),
          collateralPercent: t.collateral_percent,
          decentralisation: t.decentralisation,
          epoch: t.epoch_no,
          keyDeposit: t.key_deposit.toString(),
          maxBlockExMem: t.max_block_ex_mem.toString(),
          maxBlockExSteps: t.max_block_ex_steps.toString(),
          maxBlockHeaderSize: t.max_block_header_size,
          maxBlockSize: t.max_block_size,
          maxCollateralInputs: t.max_collateral_inputs,
          maxTxExMem: t.max_tx_ex_mem.toString(),
          maxTxExSteps: t.max_tx_ex_steps.toString(),
          maxTxSize: t.max_tx_size,
          maxValSize: t.max_val_size.toString(),
          minFeeA: t.min_fee_a,
          minFeeB: t.min_fee_b,
          minPoolCost: t.min_pool_cost.toString(),
          poolDeposit: t.pool_deposit.toString(),
          priceMem: t.price_mem,
          priceStep: t.price_step
        };
      throw C(t);
    } catch (t) {
      throw C(t);
    }
  }
  async submitTx(e) {
    try {
      const t = { "Content-Type": "application/json" }, { data: r, status: i } = await this._axiosInstance.post("transactions/submit", { tx: e }, { headers: t });
      if (i === 200)
        return r.tx_id;
      throw C(r);
    } catch (t) {
      throw C(t);
    }
  }
}
class ar {
  static withOneSignature(e) {
    const t = K(tt(e));
    return ht(t).to_hex();
  }
  static withAtLeastNSignatures(e, t) {
    const r = a.NativeScripts.new();
    e.forEach((n) => {
      const o = K(tt(n));
      r.add(ht(o));
    });
    const i = a.ScriptNOfK.new(t, r);
    return a.NativeScript.new_script_any(i).to_hex();
  }
  static withAnySignature(e) {
    const t = a.NativeScripts.new();
    e.forEach((i) => {
      const n = K(tt(i));
      t.add(ht(n));
    });
    const r = a.ScriptAny.new(t);
    return a.NativeScript.new_script_any(r).to_hex();
  }
  static withAllSignatures(e) {
    const t = a.NativeScripts.new();
    e.forEach((i) => {
      const n = K(tt(i));
      t.add(ht(n));
    });
    const r = a.ScriptAll.new(t);
    return a.NativeScript.new_script_any(r).to_hex();
  }
  static fromNativeScript(e) {
    return Bt(e).to_hex();
  }
}
function z(s, e, t, r) {
  var i = arguments.length, n = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(s, e, t, r);
  else
    for (var c = s.length - 1; c >= 0; c--)
      (o = s[c]) && (n = (i < 3 ? o(n) : i > 3 ? o(e, t, n) : o(e, t)) || n);
  return i > 3 && n && Object.defineProperty(e, t, n), n;
}
const Ps = (s) => class extends s {
  __visits = [];
}, X = () => function(s, e, t) {
  const r = t.value;
  t.value = function(...i) {
    const n = r.call(this, ...i);
    return this.__visits && this.__visits.push(e), n;
  };
};
let T = class {
  _changeAddress;
  _recipients = /* @__PURE__ */ new Map();
  _totalBurns = /* @__PURE__ */ new Map();
  _totalMints = /* @__PURE__ */ new Map();
  _era;
  _initiator;
  _protocolParameters;
  _txBuilder;
  _txCertificates;
  _txInputsBuilder;
  _txWithdrawals;
  constructor(e = {}) {
    this._era = e.era, this._initiator = e.initiator, this._protocolParameters = e.parameters ?? P, this._txBuilder = as(e.parameters), this._txCertificates = a.Certificates.new(), this._txInputsBuilder = a.TxInputsBuilder.new(), this._txWithdrawals = a.Withdrawals.new();
  }
  static maskMetadata(e) {
    var i;
    const t = q(e), r = (i = t.auxiliary_data()) == null ? void 0 : i.metadata();
    if (r !== void 0) {
      const n = a.GeneralTransactionMetadata.new();
      for (let c = 0; c < r.len(); c += 1) {
        const A = r.keys().get(c), u = r.get(A);
        n.insert(A, a.TransactionMetadatum.from_hex("0".repeat(((u == null ? void 0 : u.to_hex()) ?? "").length)));
      }
      const o = t.auxiliary_data();
      return o == null || o.set_metadata(n), a.Transaction.new(t.body(), t.witness_set(), o).to_hex();
    }
    return e;
  }
  static readMetadata(e) {
    var r, i;
    return ((i = (r = q(e).auxiliary_data()) == null ? void 0 : r.metadata()) == null ? void 0 : i.to_hex()) ?? "";
  }
  static writeMetadata(e, t) {
    const r = q(e), i = r.auxiliary_data() ?? a.AuxiliaryData.new();
    return i.set_metadata(a.GeneralTransactionMetadata.from_hex(t)), a.Transaction.new(r.body(), r.witness_set(), i).to_hex();
  }
  get size() {
    return this._txBuilder.full_size();
  }
  async build() {
    try {
      return this.notVisited("redeemValue") === !1 && (await this.addRequiredSignersIfNeeded(), await this.addCollateralIfNeeded()), await this.forgeAssetsIfNeeded(), await this.addTxInputsAsNeeded(), await this.addChangeAddress(), this._txBuilder.build_tx().to_hex();
    } catch (e) {
      throw new Error(`[Transaction] An error occurred during build: ${e}.`);
    }
  }
  burnAsset(e, t) {
    const r = this._totalBurns.has(t.unit) ? a.BigNum.from_str(this._totalBurns.get(t.unit) ?? "0").checked_add(a.BigNum.from_str(t.quantity)).to_str() : t.quantity;
    return this._txBuilder.add_mint_asset(ft(e), a.AssetName.new(g(t.unit.slice(L))), a.Int.new_negative(a.BigNum.from_str(t.quantity))), this._totalBurns.set(t.unit, r), this;
  }
  delegateStake(e, t) {
    const r = a.Certificate.new_stake_delegation(a.StakeDelegation.new(a.StakeCredential.from_keyhash(K(gt(e))), a.Ed25519KeyHash.from_bech32(t)));
    return this._txCertificates.add(r), this;
  }
  deregisterStake(e) {
    const t = a.Certificate.new_stake_deregistration(a.StakeDeregistration.new(a.StakeCredential.from_keyhash(K(gt(e)))));
    return this._txCertificates.add(t), this;
  }
  mintAsset(e, t) {
    var c, A;
    const i = ((u, I) => {
      const h = ft(u).hash().to_hex(), _ = j(I.assetName);
      return {
        unit: `${h}${_}`,
        quantity: I.assetQuantity
      };
    })(e, t), o = a.BigNum.from_str(((c = this._totalMints.get(i.unit)) == null ? void 0 : c.assetQuantity) ?? "0").checked_add(a.BigNum.from_str(i.quantity));
    return this._txBuilder.add_mint_asset(ft(e), a.AssetName.new(g(j(t.assetName))), a.Int.new(a.BigNum.from_str(i.quantity))), this._recipients.has(t.recipient) ? (A = this._recipients.get(t.recipient)) == null || A.push(i) : this._recipients.set(t.recipient, [i]), this._totalMints.set(i.unit, {
      ...t,
      assetQuantity: o.to_str()
    }), this;
  }
  redeemValue(e) {
    if ("assetName" in e.value)
      throw new Error("Plutus Minting is not implemented yet...");
    const t = {
      tag: "SPEND",
      budget: Ye,
      index: this._txInputsBuilder.inputs().len(),
      data: {
        alternative: 0,
        fields: []
      },
      ...e.redeemer
    }, r = R(e.value), i = a.PlutusWitness.new_with_ref(is(e.script), rs(e.datum), Ze(t));
    return this._txInputsBuilder.add_plutus_script_input(i, r.input(), r.output().amount()), this;
  }
  registerStake(e) {
    const t = a.Certificate.new_stake_registration(a.StakeRegistration.new(a.StakeCredential.from_keyhash(K(gt(e)))));
    return this._txCertificates.add(t), this;
  }
  registerPool(e) {
    const t = a.Certificate.new_pool_registration(a.PoolRegistration.new(Xe(e)));
    return this._txCertificates.add(t), this;
  }
  retirePool(e, t) {
    const r = a.Certificate.new_pool_retirement(a.PoolRetirement.new(a.Ed25519KeyHash.from_bech32(e), t));
    return this._txCertificates.add(r), this;
  }
  sendAssets(e, t) {
    const r = Ct(t), i = r.multiasset();
    if (r.is_zero() || i === void 0)
      return this;
    const o = ut(e).next().with_asset_and_min_required_coin_by_utxo_cost(i, Wt(this._protocolParameters.coinsPerUTxOSize)).build();
    return this._txBuilder.add_output(o), this;
  }
  sendLovelace(e, t) {
    const i = ut(e).next().with_coin(a.BigNum.from_str(t)).build();
    return this._txBuilder.add_output(i), this;
  }
  sendValue(e, t) {
    const r = Ct(t.output.amount), n = ut(e).next().with_value(r).build();
    return this._txBuilder.add_output(n), this;
  }
  setChangeAddress(e) {
    return this._changeAddress = U(e), this;
  }
  setCollateral(e) {
    const t = Xt(e);
    return this._txBuilder.set_collateral(t), this;
  }
  setMetadata(e, t) {
    return this._txBuilder.add_json_metadatum_with_schema(a.BigNum.from_str(e.toString()), JSON.stringify(t), a.MetadataJsonSchema.NoConversions), this;
  }
  setRequiredSigners(e) {
    return Array.from(new Set(e.map((r) => r.startsWith("addr") ? tt(r) : gt(r)).map((r) => K(r)))).forEach((r) => {
      this._txBuilder.add_required_signer(r);
    }), this;
  }
  setTimeToStart(e) {
    return this._txBuilder.set_validity_start_interval_bignum(a.BigNum.from_str(e)), this;
  }
  setTimeToExpire(e) {
    return this._txBuilder.set_ttl_bignum(a.BigNum.from_str(e)), this;
  }
  setTxInputs(e) {
    return e.map((t) => R(t)).forEach((t) => {
      this._txInputsBuilder.add_input(t.output().address(), t.input(), t.output().amount());
    }), this;
  }
  withdrawRewards(e, t) {
    const r = _e(e);
    return r !== void 0 && this._txWithdrawals.insert(r, a.BigNum.from_str(t)), this;
  }
  async addBurnInputsIfNeeded() {
    if (this._initiator && this._totalBurns.size > 0 && this.notVisited("setTxInputs")) {
      const e = await this._initiator.getUsedUTxOs();
      os(this._totalBurns, e.map((r) => Et(r))).map((r) => R(r)).forEach((r) => {
        this._txInputsBuilder.add_input(r.output().address(), r.input(), r.output().amount());
      });
    }
  }
  async addChangeAddress() {
    if (this._initiator && this._changeAddress === void 0) {
      const e = await this._initiator.getUsedAddress();
      this._txBuilder.add_change_if_needed(e);
    } else
      this._changeAddress !== void 0 && this._txBuilder.add_change_if_needed(this._changeAddress);
  }
  async addCollateralIfNeeded() {
    if (this._initiator && this.notVisited("setCollateral")) {
      const e = await this._initiator.getUsedCollateral();
      this._txBuilder.set_collateral(Xt(e));
    }
  }
  async addRequiredSignersIfNeeded() {
    if (this._initiator && this.notVisited("setRequiredSigners")) {
      const e = await this._initiator.getUsedAddress(), t = tt(e.to_bech32());
      this._txBuilder.add_required_signer(K(t));
    }
  }
  async addTxInputsAsNeeded() {
    if (this._txBuilder.set_inputs(this._txInputsBuilder), this._txCertificates.len() > 0 && this._txBuilder.set_certs(this._txCertificates), this._txWithdrawals.len() > 0 && this._txBuilder.set_withdrawals(this._txWithdrawals), this.notVisited("setTxInputs")) {
      const e = !this.notVisited("mintAsset") || !this.notVisited("sendAssets") || !this.notVisited("sendValue"), t = await this.selectLovelaceUTxOs(!1), r = await this.filterAvailableUTxOs(t), i = e ? a.CoinSelectionStrategyCIP2.LargestFirstMultiAsset : a.CoinSelectionStrategyCIP2.LargestFirst;
      this._txBuilder.add_inputs_from(r, i);
    }
    if (this.notVisited("redeemValue") === !1) {
      const e = this._era !== void 0 ? Lt[this._era] : Lt.BABBAGE;
      this._txBuilder.calc_script_data_hash(e);
    }
  }
  async forgeAssetsIfNeeded() {
    const e = (t, r) => {
      const i = t.data.assetName, n = t.data.metadata, o = t.unit.slice(0, L);
      if (r && r[o]) {
        const { [o]: c, ...A } = r, u = {
          [i]: n,
          ...c
        };
        return {
          [o]: {
            ...u
          },
          ...A
        };
      }
      return r !== void 0 ? {
        [o]: {
          [i]: n
        },
        ...r
      } : {
        [o]: { [i]: n }
      };
    };
    await this.addBurnInputsIfNeeded(), Array.from(this._totalMints, (t) => ({
      unit: t[0],
      data: t[1]
    })).reduce((t, r) => t.set(r.data.label, e(r, t.get(r.data.label))), /* @__PURE__ */ new Map()).forEach((t, r) => {
      this._txBuilder.add_json_metadatum(a.BigNum.from_str(r), JSON.stringify(t));
    }), this.addMintOutputs();
  }
  async filterAvailableUTxOs(e = []) {
    const t = a.TransactionUnspentOutputs.new();
    return this._initiator === void 0 || (await this._initiator.getUsedUTxOs()).filter((i) => e.find((n) => n.input.txHash === i.input().transaction_id().to_hex()) === void 0).forEach((i) => {
      t.add(i);
    }), t;
  }
  async selectLovelaceUTxOs(e) {
    if (this._initiator === void 0 || e === !1)
      return [];
    const t = await this._initiator.getUsedUTxOs(), r = ns("5000000", t.map((n) => Et(n)));
    return r.map((n) => R(n)).forEach((n) => {
      this._txBuilder.add_input(n.output().address(), n.input(), n.output().amount());
    }), r;
  }
  addMintOutputs() {
    this._recipients.forEach((e, t) => {
      const i = Ct(e).multiasset();
      if (i !== void 0) {
        const o = ut(t).next().with_asset_and_min_required_coin_by_utxo_cost(i, Wt(this._protocolParameters.coinsPerUTxOSize)).build();
        this._txBuilder.add_output(o);
      }
    });
  }
  notVisited(e) {
    return this.__visits.includes(e) === !1;
  }
};
z([
  X()
], T.prototype, "mintAsset", null);
z([
  X()
], T.prototype, "redeemValue", null);
z([
  X()
], T.prototype, "sendAssets", null);
z([
  X()
], T.prototype, "sendValue", null);
z([
  X()
], T.prototype, "setCollateral", null);
z([
  X()
], T.prototype, "setRequiredSigners", null);
z([
  X()
], T.prototype, "setTxInputs", null);
T = z([
  Ps
], T);
const ke = (s, e) => {
  const t = s.vkeys();
  if (t !== void 0) {
    const r = /* @__PURE__ */ new Set();
    for (let n = 0; n < t.len(); n += 1)
      r.add(t.get(n).to_hex());
    for (let n = 0; n < e.len(); n += 1)
      r.add(e.get(n).to_hex());
    const i = a.Vkeywitnesses.new();
    return r.forEach((n) => {
      i.add(a.Vkeywitness.from_hex(n));
    }), i;
  }
  return e;
};
class w {
  _networkId;
  _encryptedSecret;
  constructor(e, t) {
    this._networkId = e, this._encryptedSecret = t;
  }
  getAccount(e, t) {
    return this.accountContext(e, t, (r, i) => {
      const n = Jt(this._networkId, r.to_public().hash(), i.to_public().hash()).to_address().to_bech32(), o = jt(this._networkId, r.to_public().hash()).to_address().to_bech32(), c = Kt(this._networkId, i.to_public().hash()).to_address().to_bech32();
      return {
        baseAddress: n,
        enterpriseAddress: o,
        rewardAddress: c
      };
    });
  }
  signData(e, t, r, i) {
    try {
      return this.accountContext(e, t, (n, o) => {
        const c = { payload: i }, A = {
          address: w.resolveAddress(this._networkId, r, n, o),
          key: r.startsWith("stake") ? o : n
        }, { coseSign1: u, coseKey: I } = Is(c, A);
        return { signature: u, key: I };
      });
    } catch (n) {
      throw new Error(`An error occurred during signData: ${n}.`);
    }
  }
  signTx(e, t, r, i, n) {
    try {
      const o = fe(Ns(i));
      return this.accountContext(e, t, (c, A) => {
        const u = a.Vkeywitnesses.new();
        return w.resolveSigners(i, r, c.to_public().hash().to_hex()).forEach((h) => {
          if (h === c.to_public().hash().to_hex())
            u.add(a.make_vkey_witness(o, c));
          else if (h === A.to_public().hash().to_hex())
            u.add(a.make_vkey_witness(o, A));
          else if (n === !1)
            throw new Error(`Missing key witness for: ${h}`);
        }), u;
      });
    } catch (o) {
      throw new Error(`An error occurred during signTx: ${o}.`);
    }
  }
  static encryptMnemonic(e, t) {
    const r = le(e.join(" ")), i = we(r), n = W(i.as_bytes());
    return i.free(), w.encrypt(n, t);
  }
  static encryptPrivateKey(e, t) {
    const r = a.Bip32PrivateKey.from_bech32(e), i = W(r.as_bytes());
    return r.free(), w.encrypt(i, t);
  }
  static encryptSigningKeys(e, t, r) {
    const i = w.encrypt(e.slice(4), r), n = w.encrypt(t.slice(4), r);
    return [i, n];
  }
  static generateMnemonic(e = 256) {
    return He(e).split(" ");
  }
  accountContext(e, t, r) {
    const { paymentKey: i, stakeKey: n } = w.resolveKeys(e, t, this._encryptedSecret), o = r(i, n);
    return i.free(), n.free(), o;
  }
  static decrypt(e, t) {
    try {
      return a.decrypt_with_password(j(t), e);
    } catch {
      throw new Error("The password is incorrect.");
    }
  }
  static encrypt(e, t) {
    const r = Oe("0123456789abcdef"), i = r(64), n = r(24);
    return a.encrypt_with_password(j(t), i, n, e);
  }
  static resolveAddress(e, t, r, i) {
    const n = [
      Jt(e, r.to_public().hash(), i.to_public().hash()),
      jt(e, r.to_public().hash()),
      Kt(e, i.to_public().hash())
    ].find((o) => o.to_address().to_bech32() === t);
    if (n !== void 0)
      return n.to_address();
    throw new Error(`Address: ${t} doesn't belong to this account.`);
  }
  static resolveKeys(e, t, r) {
    if (typeof r == "string") {
      const o = w.decrypt(r, t);
      return Fs(o, e);
    }
    const i = w.decrypt(r[0], t), n = w.decrypt(r[1], t);
    return {
      paymentKey: a.PrivateKey.from_hex(i),
      stakeKey: a.PrivateKey.from_hex(n)
    };
  }
  static resolveSigners(e, t, r) {
    const i = (c) => {
      const A = (l, m = [], E = 0) => {
        var It, at, Mt, Tt, Vt;
        if (l === void 0 || E >= l.len())
          return m;
        const x = l.get(E), S = new Array();
        switch (x.kind()) {
          case a.CertificateKind.StakeDeregistration: {
            const p = (It = x.as_stake_deregistration()) == null ? void 0 : It.stake_credential(), H = (p == null ? void 0 : p.kind()) === a.StakeCredKind.Key ? p.to_keyhash() : void 0;
            H && S.push(H.to_hex());
            break;
          }
          case a.CertificateKind.StakeDelegation: {
            const p = (at = x.as_stake_delegation()) == null ? void 0 : at.stake_credential(), H = (p == null ? void 0 : p.kind()) === a.StakeCredKind.Key ? p.to_keyhash() : void 0;
            H && S.push(H.to_hex());
            break;
          }
          case a.CertificateKind.PoolRegistration: {
            const p = (Mt = x.as_pool_registration()) == null ? void 0 : Mt.pool_params().pool_owners();
            S.push(...I(p));
            break;
          }
          case a.CertificateKind.PoolRetirement: {
            const p = (Tt = x.as_pool_retirement()) == null ? void 0 : Tt.pool_keyhash();
            p && S.push(p.to_hex());
            break;
          }
          case a.CertificateKind.MoveInstantaneousRewardsCert: {
            const p = (Vt = x.as_move_instantaneous_rewards_cert()) == null ? void 0 : Vt.move_instantaneous_reward().as_to_stake_creds();
            if (p)
              for (let H = 0; H < p.len(); H += 1) {
                const Ot = p.keys().get(H), Yt = Ot.kind() === a.StakeCredKind.Key ? Ot.to_keyhash() : void 0;
                Yt && S.push(Yt.to_hex());
              }
            break;
          }
        }
        return A(l, [...m, ...S], E + 1);
      }, u = (l, m = [], E = 0) => {
        if (l === void 0 || E >= l.len())
          return m;
        const x = l.get(E).index(), S = l.get(E).transaction_id(), It = t.find((at) => at.input.outputIndex === x && at.input.txHash === S.to_hex()) !== void 0 ? r : "OUR_PRINCESS_IS_IN_ANOTHER_CASTLE";
        return u(l, [...m, It], E + 1);
      }, I = (l, m = [], E = 0) => l === void 0 || E >= l.len() ? m : I(l, [...m, l.get(E).to_hex()], E + 1), h = (l, m = [], E = 0) => {
        if (l === void 0 || E >= l.len())
          return m;
        const x = l.keys().get(E).payment_cred(), S = x.kind() === a.StakeCredKind.Key ? x.to_keyhash() : void 0;
        return h(l, S ? [...m, S.to_hex()] : m, E + 1);
      }, _ = c.certs(), D = c.collateral(), $ = c.inputs(), F = c.required_signers(), V = c.withdrawals();
      return [
        ...A(_),
        ...u(D),
        ...u($),
        ...I(F),
        ...h(V)
      ];
    }, n = (c) => {
      const A = (I, h = []) => {
        var _, D, $, F;
        if (I)
          for (let V = 0; V < I.len(); V += 1) {
            const l = I.get(V);
            switch (l.kind()) {
              case a.NativeScriptKind.ScriptPubkey: {
                const m = (_ = l.as_script_pubkey()) == null ? void 0 : _.addr_keyhash().to_hex();
                return m ? [...h, m] : h;
              }
              case a.NativeScriptKind.ScriptAll:
                return A((D = l.as_script_all()) == null ? void 0 : D.native_scripts(), h);
              case a.NativeScriptKind.ScriptAny:
                return A(($ = l.as_script_any()) == null ? void 0 : $.native_scripts(), h);
              case a.NativeScriptKind.ScriptNOfK:
                return A((F = l.as_script_n_of_k()) == null ? void 0 : F.native_scripts(), h);
            }
          }
        return h;
      }, u = c.native_scripts();
      return [
        ...A(u)
      ];
    }, o = q(e);
    return /* @__PURE__ */ new Set([
      ...i(o.body()),
      ...n(o.witness_set())
    ]);
  }
}
const v = "MARI0TIME";
class or {
  _fetcher;
  _submitter;
  _wallet;
  constructor(e) {
    switch (this._fetcher = e.fetcher, this._submitter = e.submitter, e.key.type) {
      case "mnemonic":
        this._wallet = new w(e.networkId, w.encryptMnemonic(e.key.words, v));
        break;
      case "root":
        this._wallet = new w(e.networkId, w.encryptPrivateKey(e.key.bech32, v));
        break;
      case "cli":
        this._wallet = new w(e.networkId, w.encryptSigningKeys(e.key.payment, e.key.stake ?? "f0".repeat(34), v));
    }
  }
  getPaymentAddress(e = 0) {
    return this._wallet.getAccount(e, v).enterpriseAddress;
  }
  getRewardAddress(e = 0) {
    return this._wallet.getAccount(e, v).rewardAddress;
  }
  getUsedAddress(e = 0) {
    const t = this._wallet.getAccount(e, v);
    return U(t.enterpriseAddress);
  }
  getUsedCollateral(e = P.maxCollateralInputs) {
    throw new Error("getUsedCollateral not implemented.");
  }
  async getUsedUTxOs(e = 0) {
    const t = this._wallet.getAccount(e, v);
    return (await this._fetcher.fetchAddressUTxOs(t.enterpriseAddress)).map((i) => R(i));
  }
  signData(e, t, r = 0) {
    try {
      return this._wallet.signData(r, v, e, t);
    } catch (i) {
      throw new Error(`[AppWallet] An error occurred during signData: ${i}.`);
    }
  }
  async signTx(e, t = !1, r = 0) {
    try {
      const i = this._wallet.getAccount(r, v), n = await this._fetcher.fetchAddressUTxOs(i.enterpriseAddress), o = this._wallet.signTx(r, v, n, e, t), c = q(e), A = c.witness_set(), u = ke(A, o);
      return A.set_vkeys(u), a.Transaction.new(c.body(), A, c.auxiliary_data()).to_hex();
    } catch (i) {
      throw new Error(`[AppWallet] An error occurred during signTx: ${i}.`);
    }
  }
  submitTx(e) {
    return this._submitter.submitTx(e);
  }
  static brew(e = 256) {
    return w.generateMnemonic(e);
  }
}
class Ut {
  _walletInstance;
  constructor(e) {
    this._walletInstance = e;
  }
  static getInstalledWallets() {
    return window.cardano === void 0 ? [] : qt.filter((e) => window.cardano[e] !== void 0).map((e) => ({
      name: window.cardano[e].name,
      icon: window.cardano[e].icon,
      version: window.cardano[e].apiVersion
    }));
  }
  static async enable(e) {
    try {
      const t = await Ut.resolveInstance(e);
      if (t !== void 0)
        return new Ut(t);
      throw new Error(`Couldn't create an instance of wallet: ${e}`);
    } catch (t) {
      throw new Error(`[BrowserWallet] An error occurred during enable: ${t}.`);
    }
  }
  async getBalance() {
    const e = await this._walletInstance.getBalance();
    return pe(je(e));
  }
  async getChangeAddress() {
    const e = await this._walletInstance.getChangeAddress();
    return nt(e).to_bech32();
  }
  async getCollateral(e = P.maxCollateralInputs) {
    return (await this.getUsedCollateral(e)).map((r) => Et(r));
  }
  getNetworkId() {
    return this._walletInstance.getNetworkId();
  }
  async getRewardAddresses() {
    return (await this._walletInstance.getRewardAddresses()).map((t) => nt(t).to_bech32());
  }
  async getUnusedAddresses() {
    return (await this._walletInstance.getUnusedAddresses()).map((t) => nt(t).to_bech32());
  }
  async getUsedAddresses() {
    return (await this._walletInstance.getUsedAddresses()).map((t) => nt(t).to_bech32());
  }
  async getUtxos() {
    return (await this.getUsedUTxOs()).map((t) => Et(t));
  }
  signData(e, t) {
    const r = U(e).to_hex();
    return this._walletInstance.signData(r, j(t));
  }
  async signTx(e, t = !1) {
    try {
      const r = q(e), i = r.witness_set(), n = await this._walletInstance.signTx(e, t), o = We(n).vkeys() ?? a.Vkeywitnesses.new(), c = ke(i, o);
      return i.set_vkeys(c), W(a.Transaction.new(r.body(), i, r.auxiliary_data()).to_bytes());
    } catch (r) {
      throw new Error(`[BrowserWallet] An error occurred during signTx: ${JSON.stringify(r)}.`);
    }
  }
  submitTx(e) {
    return this._walletInstance.submitTx(e);
  }
  async getUsedAddress() {
    const e = await this._walletInstance.getUsedAddresses();
    return nt(e[0]);
  }
  async getUsedCollateral(e = P.maxCollateralInputs) {
    return (await this._walletInstance.experimental.getCollateral() ?? []).map((r) => zt(r)).slice(0, e);
  }
  async getUsedUTxOs() {
    return (await this._walletInstance.getUtxos() ?? []).map((t) => zt(t));
  }
  async getAssets() {
    return (await this.getBalance()).filter((t) => t.unit !== "lovelace").map((t) => {
      const r = t.unit.slice(0, L), i = t.unit.slice(L), n = Hs(r, i);
      return {
        unit: t.unit,
        policyId: r,
        assetName: ss(i),
        fingerprint: n,
        quantity: t.quantity
      };
    });
  }
  async getLovelace() {
    const t = (await this.getBalance()).find((r) => r.unit === "lovelace");
    return t !== void 0 ? t.quantity : "0";
  }
  async getPolicyIdAssets(e) {
    return (await this.getAssets()).filter((r) => r.policyId === e);
  }
  async getPolicyIds() {
    const e = await this.getBalance();
    return Array.from(new Set(e.map((t) => t.unit.slice(0, L)))).filter((t) => t !== "lovelace");
  }
  static resolveInstance(e) {
    if (window.cardano === void 0)
      return;
    const t = qt.map((r) => window.cardano[r]).filter((r) => r !== void 0).find((r) => r.name.toLowerCase() === e.toLowerCase());
    return t == null ? void 0 : t.enable();
  }
}
const Fe = "http://localhost:4000/", Ms = "http://localhost:5000/", Ts = `${Fe}access`, Vs = `${Fe}transaction/signtx`;
class Ar {
  static getAxiosInstance() {
    return it.create({
      baseURL: Ms,
      withCredentials: !0
    });
  }
  static getAppId() {
    return window.location.hostname;
  }
  static async openMinaFrontend(e) {
    const t = this.getAppId();
    e.includes("?") ? e = `${e}&appId=${t}` : e = `${e}?appId=${t}`;
    const r = "left=100,top=100,width=540,height=540", i = window.open(e, "meshWindow", r);
    return i || console.error("the window did not open", i), await (async () => new Promise((n) => {
      window.addEventListener("message", async (o) => {
        o.data.target == "minaWallet" && n(o.data);
      });
    }))();
  }
  static async get(e, t = {}) {
    const r = this.getAppId();
    t = {
      ...t,
      appId: r
    };
    try {
      return (await this.getAxiosInstance().get(e, {
        params: t
      })).data;
    } catch {
      console.error("Not logged in");
      return;
    }
  }
  static async enable() {
    return await this.get("wallet/getuserwalletsmeta") === void 0 ? await this.openMinaFrontend(Ts) : !0;
  }
  static async getChangeAddress(e = void 0, t = void 0) {
    return await this.get("wallet/getchangeaddress", {
      walletId: e,
      accountIndex: t
    });
  }
  static async getUtxos(e = void 0, t = void 0) {
    return await this.get("wallet/getutxo", {
      walletId: e,
      accountIndex: t
    });
  }
  static async signTx(e, t = !1) {
    const r = await this.get("wallet/getuserwalletsmeta");
    if (console.log("userWalletsMeta", r), r) {
      const i = await this.openMinaFrontend(`${Vs}?unsignedTx=${e}&partialSign=${t}`);
      if (i instanceof a.Vkeywitnesses) {
        const n = q(e), o = n.witness_set();
        o.set_vkeys(i);
        const c = a.Transaction.new(n.body(), o, n.auxiliary_data()).to_hex();
        return console.log("signedTx", c), c;
      }
    } else
      return;
  }
}
export {
  or as AppWallet,
  er as BlockfrostProvider,
  Ut as BrowserWallet,
  w as EmbeddedWallet,
  ar as ForgeScript,
  sr as InfuraProvider,
  rr as KoiosProvider,
  Ar as MinaWallet,
  ir as TangoProvider,
  T as Transaction,
  ns as largestFirst,
  os as largestFirstMultiAsset,
  Ls as resolveDataHash,
  qs as resolveEpochNo,
  Hs as resolveFingerprint,
  zs as resolveLanguageView,
  $s as resolveNativeScriptHash,
  tt as resolvePaymentKeyHash,
  Js as resolvePlutusScriptAddress,
  Ws as resolvePlutusScriptHash,
  js as resolvePoolId,
  Xs as resolvePrivateKey,
  Pt as resolveRewardAddress,
  Zs as resolveScriptRef,
  tr as resolveSlotNo,
  gt as resolveStakeKeyHash,
  Ue as resolveTxFees,
  Ns as resolveTxHash
};
